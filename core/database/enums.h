// SPDX-FileCopyrightText: 2021-2024 Niels Moseley <asicsforthemasses@gmail.com>
// SPDX-License-Identifier: GPL-3.0-only
// Apr 18 2024
// Auto generated by enumgen - part of LunaPnR

#pragma once
#include <string>
#include <string_view>
#include <iostream>
#include <array>

#ifndef DEF_ENUMTAG
	#define DEF_ENUMTAG
	struct EnumTag{};
#endif


namespace ChipDB
{

class CellClass : public EnumTag
{
public:
    constexpr static int UNDEFINED = -1;
	constexpr static int NONE = 0;
	constexpr static int CORE = 1;
	constexpr static int COVER = 2;
	constexpr static int RING = 3;
	constexpr static int PAD = 4;
	constexpr static int ENDCAP = 5;
	constexpr static int BLOCK = 6;

	const std::array<const char*, 7> m_names = {
		"NONE",
		"CORE",
		"COVER",
		"RING",
		"PAD",
		"ENDCAP",
		"BLOCK"};


    CellClass() = default;
    explicit CellClass(const int value) : m_value(value) {};

    std::string toString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return "UNDEFINED";
        }

        return m_names.at(m_value);
    }

    const char* toCString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return undefinedStr;
        }

        return m_names[m_value];
    }

    std::string_view toStringView() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return std::string_view(undefinedStr);
        }

        return std::string_view(m_names[m_value]);
    }

    /** convert the string into an enum value.
        if the string isn't recognized, false is returned
    */
    bool fromString(const std::string_view optName) noexcept
    {
        int index = 0;
        for(auto const& name : m_names)
        {
            if (optName == name)
            {
                m_value = index;
                return true;
            }

            index++;
        }
        return false;
    }

    constexpr void operator=(const CellClass &e) noexcept
    {
        m_value = e.m_value;
    }

    constexpr void operator=(int value) noexcept
    {
        m_value = value;
    }

    void operator=(const std::string &value) noexcept
    {
        fromString(value);
    }

    void operator=(const std::string_view value) noexcept
    {
        fromString(value);
    }

    constexpr bool operator==(const int value) const noexcept
    {
        return m_value == value;
    }

    constexpr bool operator==(const CellClass &e) const noexcept
    {
        return m_value == e.m_value;
    }

    bool operator==(const std::string &value) const noexcept
    {
        return toString() == value;
    }

    constexpr bool operator!=(const int value) const noexcept
    {
        return m_value != value;
    }

    constexpr bool operator!=(const CellClass &e) const noexcept
    {
        return m_value != e.m_value;
    }

    bool operator!=(const std::string &value) const noexcept
    {
        return toString() != value;
    }

    constexpr int value() const noexcept
    {
        return m_value;
    }

    auto begin() const
    {
        return m_names.begin();
    }

    auto end() const
    {
        return m_names.end();
    }

    constexpr bool isValid() const noexcept
    {
        return (m_value >= 0) && (m_value < 7);
    }

protected:
    static constexpr const char* undefinedStr = "UNDEFINED";
    int m_value{UNDEFINED};
};

inline std::string toString(const ChipDB::CellClass &e)
{
    return e.toString();
}

inline bool fromString(const char *v, ChipDB::CellClass &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(std::string_view v, ChipDB::CellClass &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(const std::string &v, ChipDB::CellClass &result)
{
    result.fromString(v);
    return result.isValid();
}


};    // end namespace ChipDB


inline std::ostream& operator<<(std::ostream& os, const ChipDB::CellClass &e)
{
    os << e.toString();
    return os;
};


namespace ChipDB
{

class CellSubclass : public EnumTag
{
public:
    constexpr static int UNDEFINED = -1;
	constexpr static int NONE = 0;
	constexpr static int BUMP = 1;
	constexpr static int BLACKBOX = 2;
	constexpr static int SOFT = 3;
	constexpr static int INPUT = 4;
	constexpr static int OUTPUT = 5;
	constexpr static int INOUT = 6;
	constexpr static int POWER = 7;
	constexpr static int SPACER = 8;
	constexpr static int DECAP = 9;
	constexpr static int AREAIO = 10;
	constexpr static int FEEDTHRU = 11;
	constexpr static int TIEHIGH = 12;
	constexpr static int TIELOW = 13;
	constexpr static int ANTENNACELL = 14;
	constexpr static int WELLTAP = 15;
	constexpr static int PRE = 16;
	constexpr static int POST = 17;
	constexpr static int TOPLEFT = 18;
	constexpr static int TOPRIGHT = 19;
	constexpr static int BOTTOMLEFT = 20;
	constexpr static int BOTTOMRIGHT = 21;

	const std::array<const char*, 22> m_names = {
		"NONE",
		"BUMP",
		"BLACKBOX",
		"SOFT",
		"INPUT",
		"OUTPUT",
		"INOUT",
		"POWER",
		"SPACER",
		"DECAP",
		"AREAIO",
		"FEEDTHRU",
		"TIEHIGH",
		"TIELOW",
		"ANTENNACELL",
		"WELLTAP",
		"PRE",
		"POST",
		"TOPLEFT",
		"TOPRIGHT",
		"BOTTOMLEFT",
		"BOTTOMRIGHT"};


    CellSubclass() = default;
    explicit CellSubclass(const int value) : m_value(value) {};

    std::string toString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return "UNDEFINED";
        }

        return m_names.at(m_value);
    }

    const char* toCString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return undefinedStr;
        }

        return m_names[m_value];
    }

    std::string_view toStringView() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return std::string_view(undefinedStr);
        }

        return std::string_view(m_names[m_value]);
    }

    /** convert the string into an enum value.
        if the string isn't recognized, false is returned
    */
    bool fromString(const std::string_view optName) noexcept
    {
        int index = 0;
        for(auto const& name : m_names)
        {
            if (optName == name)
            {
                m_value = index;
                return true;
            }

            index++;
        }
        return false;
    }

    constexpr void operator=(const CellSubclass &e) noexcept
    {
        m_value = e.m_value;
    }

    constexpr void operator=(int value) noexcept
    {
        m_value = value;
    }

    void operator=(const std::string &value) noexcept
    {
        fromString(value);
    }

    void operator=(const std::string_view value) noexcept
    {
        fromString(value);
    }

    constexpr bool operator==(const int value) const noexcept
    {
        return m_value == value;
    }

    constexpr bool operator==(const CellSubclass &e) const noexcept
    {
        return m_value == e.m_value;
    }

    bool operator==(const std::string &value) const noexcept
    {
        return toString() == value;
    }

    constexpr bool operator!=(const int value) const noexcept
    {
        return m_value != value;
    }

    constexpr bool operator!=(const CellSubclass &e) const noexcept
    {
        return m_value != e.m_value;
    }

    bool operator!=(const std::string &value) const noexcept
    {
        return toString() != value;
    }

    constexpr int value() const noexcept
    {
        return m_value;
    }

    auto begin() const
    {
        return m_names.begin();
    }

    auto end() const
    {
        return m_names.end();
    }

    constexpr bool isValid() const noexcept
    {
        return (m_value >= 0) && (m_value < 22);
    }

protected:
    static constexpr const char* undefinedStr = "UNDEFINED";
    int m_value{UNDEFINED};
};

inline std::string toString(const ChipDB::CellSubclass &e)
{
    return e.toString();
}

inline bool fromString(const char *v, ChipDB::CellSubclass &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(std::string_view v, ChipDB::CellSubclass &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(const std::string &v, ChipDB::CellSubclass &result)
{
    result.fromString(v);
    return result.isValid();
}


};    // end namespace ChipDB


inline std::ostream& operator<<(std::ostream& os, const ChipDB::CellSubclass &e)
{
    os << e.toString();
    return os;
};


namespace ChipDB
{

class Orientation : public EnumTag
{
public:
    constexpr static int UNDEFINED = -1;
	constexpr static int R0 = 0;
	constexpr static int R90 = 1;
	constexpr static int R180 = 2;
	constexpr static int R270 = 3;
	constexpr static int MX = 4;
	constexpr static int MX90 = 5;
	constexpr static int MY = 6;
	constexpr static int MY90 = 7;

	const std::array<const char*, 8> m_names = {
		"R0",
		"R90",
		"R180",
		"R270",
		"MX",
		"MX90",
		"MY",
		"MY90"};


    Orientation() = default;
    explicit Orientation(const int value) : m_value(value) {};

    std::string toString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return "UNDEFINED";
        }

        return m_names.at(m_value);
    }

    const char* toCString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return undefinedStr;
        }

        return m_names[m_value];
    }

    std::string_view toStringView() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return std::string_view(undefinedStr);
        }

        return std::string_view(m_names[m_value]);
    }

    /** convert the string into an enum value.
        if the string isn't recognized, false is returned
    */
    bool fromString(const std::string_view optName) noexcept
    {
        int index = 0;
        for(auto const& name : m_names)
        {
            if (optName == name)
            {
                m_value = index;
                return true;
            }

            index++;
        }
        return false;
    }

    constexpr void operator=(const Orientation &e) noexcept
    {
        m_value = e.m_value;
    }

    constexpr void operator=(int value) noexcept
    {
        m_value = value;
    }

    void operator=(const std::string &value) noexcept
    {
        fromString(value);
    }

    void operator=(const std::string_view value) noexcept
    {
        fromString(value);
    }

    constexpr bool operator==(const int value) const noexcept
    {
        return m_value == value;
    }

    constexpr bool operator==(const Orientation &e) const noexcept
    {
        return m_value == e.m_value;
    }

    bool operator==(const std::string &value) const noexcept
    {
        return toString() == value;
    }

    constexpr bool operator!=(const int value) const noexcept
    {
        return m_value != value;
    }

    constexpr bool operator!=(const Orientation &e) const noexcept
    {
        return m_value != e.m_value;
    }

    bool operator!=(const std::string &value) const noexcept
    {
        return toString() != value;
    }

    constexpr int value() const noexcept
    {
        return m_value;
    }

    auto begin() const
    {
        return m_names.begin();
    }

    auto end() const
    {
        return m_names.end();
    }

    constexpr bool isValid() const noexcept
    {
        return (m_value >= 0) && (m_value < 8);
    }

protected:
    static constexpr const char* undefinedStr = "UNDEFINED";
    int m_value{UNDEFINED};
};

inline std::string toString(const ChipDB::Orientation &e)
{
    return e.toString();
}

inline bool fromString(const char *v, ChipDB::Orientation &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(std::string_view v, ChipDB::Orientation &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(const std::string &v, ChipDB::Orientation &result)
{
    result.fromString(v);
    return result.isValid();
}


};    // end namespace ChipDB


inline std::ostream& operator<<(std::ostream& os, const ChipDB::Orientation &e)
{
    os << e.toString();
    return os;
};


namespace ChipDB
{

class PlacementInfo : public EnumTag
{
public:
    constexpr static int UNDEFINED = -1;
	constexpr static int IGNORE = 0;
	constexpr static int UNPLACED = 1;
	constexpr static int PLACED = 2;
	constexpr static int PLACEDANDFIXED = 3;

	const std::array<const char*, 4> m_names = {
		"IGNORE",
		"UNPLACED",
		"PLACED",
		"PLACEDANDFIXED"};


    PlacementInfo() = default;
    explicit PlacementInfo(const int value) : m_value(value) {};

    std::string toString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return "UNDEFINED";
        }

        return m_names.at(m_value);
    }

    const char* toCString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return undefinedStr;
        }

        return m_names[m_value];
    }

    std::string_view toStringView() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return std::string_view(undefinedStr);
        }

        return std::string_view(m_names[m_value]);
    }

    /** convert the string into an enum value.
        if the string isn't recognized, false is returned
    */
    bool fromString(const std::string_view optName) noexcept
    {
        int index = 0;
        for(auto const& name : m_names)
        {
            if (optName == name)
            {
                m_value = index;
                return true;
            }

            index++;
        }
        return false;
    }

    constexpr void operator=(const PlacementInfo &e) noexcept
    {
        m_value = e.m_value;
    }

    constexpr void operator=(int value) noexcept
    {
        m_value = value;
    }

    void operator=(const std::string &value) noexcept
    {
        fromString(value);
    }

    void operator=(const std::string_view value) noexcept
    {
        fromString(value);
    }

    constexpr bool operator==(const int value) const noexcept
    {
        return m_value == value;
    }

    constexpr bool operator==(const PlacementInfo &e) const noexcept
    {
        return m_value == e.m_value;
    }

    bool operator==(const std::string &value) const noexcept
    {
        return toString() == value;
    }

    constexpr bool operator!=(const int value) const noexcept
    {
        return m_value != value;
    }

    constexpr bool operator!=(const PlacementInfo &e) const noexcept
    {
        return m_value != e.m_value;
    }

    bool operator!=(const std::string &value) const noexcept
    {
        return toString() != value;
    }

    constexpr int value() const noexcept
    {
        return m_value;
    }

    auto begin() const
    {
        return m_names.begin();
    }

    auto end() const
    {
        return m_names.end();
    }

    constexpr bool isValid() const noexcept
    {
        return (m_value >= 0) && (m_value < 4);
    }

protected:
    static constexpr const char* undefinedStr = "UNDEFINED";
    int m_value{UNDEFINED};
};

inline std::string toString(const ChipDB::PlacementInfo &e)
{
    return e.toString();
}

inline bool fromString(const char *v, ChipDB::PlacementInfo &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(std::string_view v, ChipDB::PlacementInfo &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(const std::string &v, ChipDB::PlacementInfo &result)
{
    result.fromString(v);
    return result.isValid();
}


};    // end namespace ChipDB


inline std::ostream& operator<<(std::ostream& os, const ChipDB::PlacementInfo &e)
{
    os << e.toString();
    return os;
};

