// SPDX-FileCopyrightText: 2021-2024 Niels Moseley <asicsforthemasses@gmail.com>
//
// SPDX-License-Identifier: GPL-3.0-only

#include <iostream>
#include <sstream>

#include <toml++/toml.h>
#include <strutilspp.hpp>

using namespace StrUtils;

const std::string enumTemplate =
{R"(
###NAMESPACE_START###
class ###NAME### : public EnumTag
{
public:
    constexpr static int UNDEFINED = -1;
###VALUES###
###ARRAY###

    ###NAME###() = default;
    explicit ###NAME###(const int value) : m_value(value) {};

    std::string toString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return "UNDEFINED";
        }

        return m_names.at(m_value);
    }

    const char* toCString() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return undefinedStr;
        }

        return m_names[m_value];
    }

    std::string_view toStringView() const noexcept
    {
        if ((m_value < 0) || (m_value >= m_names.size()))
        {
            return std::string_view(undefinedStr);
        }

        return std::string_view(m_names[m_value]);
    }

    void fromString(const std::string_view optName)
    {
        int index = 0;
        for(auto const& name : m_names)
        {
            if (optName == name)
            {
                m_value = index;
                return;
            }

            index++;
        }
    }

    constexpr void operator=(const ###NAME### &e) noexcept
    {
        m_value = e.m_value;
    }

    constexpr void operator=(int value) noexcept
    {
        m_value = value;
    }

    void operator=(const std::string &value) noexcept
    {
        fromString(value);
    }

    void operator=(const std::string_view value) noexcept
    {
        fromString(value);
    }

    constexpr bool operator==(const int value) const noexcept
    {
        return m_value == value;
    }

    constexpr bool operator==(const ###NAME### &e) const noexcept
    {
        return m_value == e.m_value;
    }

    bool operator==(const std::string &value) const noexcept
    {
        return toString() == value;
    }

    constexpr bool operator!=(const int value) const noexcept
    {
        return m_value != value;
    }

    constexpr bool operator!=(const ###NAME### &e) const noexcept
    {
        return m_value != e.m_value;
    }

    bool operator!=(const std::string &value) const noexcept
    {
        return toString() != value;
    }

    constexpr int value() const noexcept
    {
        return m_value;
    }

    auto begin() const
    {
        return m_names.begin();
    }

    auto end() const
    {
        return m_names.end();
    }

    constexpr bool isValid() const noexcept
    {
        return (m_value >= 0) && (m_value < ###COUNT###);
    }

protected:
    static constexpr const char* undefinedStr = "UNDEFINED";
    int m_value{UNDEFINED};
};

inline std::string toString(const ###NAMEWITHNAMESPACE### &e)
{
    return e.toString();
}

inline bool fromString(const char *v, ###NAMEWITHNAMESPACE### &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(std::string_view v, ###NAMEWITHNAMESPACE### &result)
{
    result.fromString(v);
    return result.isValid();
}

inline bool fromString(const std::string &v, ###NAMEWITHNAMESPACE### &result)
{
    result.fromString(v);
    return result.isValid();
}

###NAMESPACE_END###

inline std::ostream& operator<<(std::ostream& os, const ###NAMEWITHNAMESPACE### &e)
{
    os << e.toString();
    return os;
};

)"
};

int main(int argc, const char *argv[])
{
    if (argc < 2)
    {
        std::cerr << "Usage: " << argv[0] << " <infile.toml> <outfile.hpp>\n";
        return EXIT_FAILURE;
    }

    std::cout << "---------------------------------\n";
    std::cout << "  EnumGen version 1.0\n";
    std::cout << "---------------------------------\n";

    toml::table tbl;

    try
    {
        tbl = toml::parse_file(argv[1]);
    }
    catch (const toml::parse_error& err)
    {
        std::cerr << "Parsing failed:\n" << err << "\n";
        return EXIT_FAILURE;
    }

    std::string result;

    // write header
    result.append("// SPDX-FileCopyrightText: 2021-2024 Niels Moseley <asicsforthemasses@gmail.com>\n");
    result.append("// SPDX-License-Identifier: GPL-3.0-only\n");
    result.append("// Auto generated by enumgen - part of LunaPnR\n\n");
    result.append("#pragma once\n");
    result.append("#include <string>\n");
    result.append("#include <string_view>\n");
    result.append("#include <iostream>\n");
    result.append("#include <array>\n\n");

    result.append("#ifndef DEF_ENUMTAG\n");
    result.append("\t#define DEF_ENUMTAG\n");
    result.append("\tstruct EnumTag{};\n");
    result.append("#endif\n\n");

    std::string namespaceStart;
    std::string namespaceEnd;
    std::string namespacePrefix;

    // check for namespace
    auto namespaceStr = tbl["namespace"].as_string();
    if (namespaceStr)
    {
        std::stringstream ss;
        ss << "namespace " << namespaceStr->get() << "\n{\n";
        namespaceStart = ss.str();

        ss.str("");
        ss << "\n};    // end namespace " << namespaceStr->get() << "\n";
        namespaceEnd = ss.str();

        namespacePrefix = namespaceStr->get();

        std::cout << "  Namespace: " << namespaceStr->get() << "\n";
    }

    auto enums = tbl["enums"].as_table();
    for (auto [key, value] : *enums)
    {
        std::cout << "  Generating enum: " << key << "\n";

        std::string valueStr;
        std::string arrayStr = "\tconst std::array<const char*, ###COUNT###> m_names = {\n";
        std::string nameWithNamespace = namespacePrefix;

        if (!namespacePrefix.empty())
        {
            nameWithNamespace.append("::");
        }

        nameWithNamespace.append(key.str());

        int counter = 0;
        auto items = value.as_array();
        if (items != nullptr)
        {
            for(auto const& item : *items)
            {
                auto str = item.as_string();
                if (str != nullptr)
                {
                    auto itemName = str->get();
                    std::stringstream ss;
                    ss << "\tconstexpr static int " << itemName << " = " << counter << ";\n";
                    valueStr.append(ss.str());

                    ss.str("");
                    if (counter != 0)
                    {
                        ss << ",\n";
                    }
                    ss << "\t\t\"" << itemName << "\"";
                    arrayStr.append(ss.str());

                    counter++;
                }
            }
            arrayStr.append("};\n");
        }

        std::string tmp = enumTemplate;

        tmp = replace(tmp, "###NAME###", key.str());
        tmp = replace(tmp, "###NAMEWITHNAMESPACE###", nameWithNamespace);
        tmp = replace(tmp, "###ARRAY###", arrayStr);
        tmp = replace(tmp, "###VALUES###", valueStr);
        tmp = replace(tmp, "###COUNT###", std::to_string(counter));
        tmp = replace(tmp, "###NAMESPACE_START###", namespaceStart);
        tmp = replace(tmp, "###NAMESPACE_END###", namespaceEnd);

        result.append(tmp);
    }

    std::ofstream ofile(argv[2]);
    if (!ofile)
    {
        std::cerr << "Cannot open " << argv[2] << " for writing!\n";
        return EXIT_FAILURE;
    }

    ofile << result;

    return EXIT_SUCCESS;
}

